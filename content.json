{"pages":[{"title":"category","text":"","link":"/category/index.html"},{"title":"tag","text":"","link":"/tag/index.html"}],"posts":[{"title":"Spring","text":"Spring概述Spring是什么？ Spring这里指Spring framework，一个用于简化Java开发的框架，也是学习Spring中其他项目的基础 Spring的好处？ 耦合低，使用IoC思想能够很好的降耦 能够很简单地使用Java EE API，如JDBC 一站式服务，能够轻松整合各种框架和第三方类库 面向切面编程 测试方便 IoCIoC：控制反转，是一种对象创建控制权由程序转移到外部的设计思想 在之前的设计思想中，当需要使用对象时就new一个对象来使用，IoC思想下，从IoC容器中获取对象 对于IoC学习中的许多概念： Bean：被实例化的、被IoC容器管理的对象 IoC容器：负责实例化、配置对象和建立对象之间的依赖的容器 定义Bean在学定义Bean前先了解Bean和IoC容器间的关系 定义Bean有三种方法 基于XML配置 基于XML配置也有多种方式：基于构造方法、基于静态工厂、基于实例工厂以及基于实例工厂的改进（实现FactoryBean） 基于构造方法：需要保证存在无参构造方法 name为Bean名称，class为Bean类型 1&lt;bean name=&quot;StuDao&quot; class=&quot;org.example.Dao.impl.StuDaoimpl&quot;/&gt; 基于注解配置 使用注解开发方式，需要创建一个配置类，在配置类中将需要定义为Bean的类添加至其Bean扫描路径，如@ComponentScan(“org.example”) 在类上添加注解 @Component或 使用Component衍生注解 表现层：@Controller 业务层：@Service 数据从：@Repository 12345678910111213// 配置类@Configuration@ComponentScan(&quot;org.example&quot;)public class SpringConfig {}// Bean@Repositorypublic class StuDaoimpl implements UserDao { @Override public void testFunc() { System.out.println(&quot;in UserDao...&quot;); }} 基于Java配置 与注解配置一样同样需要在配置类中Bean扫描路径包含Bean类，与注解配置在Bean类中操作不同的是基于Java开发在配置类中操作 基于Java配置需要在配置类中添加获取Bean对象的方法并在方法前使用@Bean注解 12345678@Configuration@ComponentScan(&quot;org.example&quot;)public class SpringConfig { @Bean public StuDaoimpl getStuDaoimpl(){ return new StuDaoimpl(); }} 获取BeanSpring中接口ApplicationContext表示IoC容器，负责管理Bean，实现ApplicationContext接口的类有： ClassPathXmlApplicationContext FileSystemXmlApplicationContext AnnotationConfigApplicationContext WebApplicationContext 要获取Bean首先需要获取IoC容器对象 FileSystemXmlApplicationContext：需要传入参数为加载XML配置文件的完整路径 ClassPathXmlApplicationContext：只需要配置CLASSPATH 环境变量 当使用注解开发时，要传入配置类而非XML配置文件时，以上两个容器就无法使用，需要使用AnnotationConfigApplicationContext AnnotationConfigApplicationContext：传入配置类.class 12ApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); 在获取容器对象后，通过容器对象的getBean方法获取Bean对象 根据getBean参数的方法来确定获取哪个Bean，有如下参数 根据Bean名称 XML配置开发时的id值即名称 基于注解开发和基于Java开发在注解后添加名称，如@Bean(“UserDao”) 根据类型 需要保证该类型Bean只有一种，否则报错 1234// 类型UserDao stuDao =ctx.getBean(StuDaoimpl.class);// 名称UserDao stuDao = (UserDao) ctx.getBean(&quot;StuDao&quot;); 生命周期Bean的生命周期：被实例化（变成可用状态）——被销毁 但是Bean有两个生命周期回调方法：init和destroy，根据定义Bean的方法不同，定义生命周期回调方法的方式也不同 基于XML配置 在JavaBean中添加init和destroy方法，在配置文件中指定init和destroy方法 1234567public void init() { System.out.println(&quot;init...&quot;); } public void destroy() { System.out.println(&quot;destroy...&quot;); } 1&lt;bean name=&quot;StuDao&quot; class=&quot;org.example.Dao.impl.StuDaoimpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt; 基于注解配置 在类中创建方法使用注解标注 12345678@PostConstructpublic void init() { System.out.println(&quot;init...&quot;);}@PreDestroypublic void destroy() { System.out.println(&quot;destroy...&quot;);} 基于Java配置 通过@Bean中的initMethod和destroyMethod指定Bean类中的方法 1234@Bean(value = &quot;StuDao1&quot;, initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)public StuDaoimpl getStuDaoimpl(){ return new StuDaoimpl();} 作用域Bean的作用域有五种，默认为singleton 改变作用域的方法，同样要根据定义Bean方式的不同使用不同的方式 基于XML配置 1&lt;bean name=&quot;StuDao&quot; class=&quot;org.example.Dao.impl.StuDaoimpl&quot; scope=&quot;prototype&quot;/&gt; 基于注解配置 注解@Scope(“prototype”) 基于Java配置 在配置类中的方法上添加注解@Scope(“prototype”) DIDI：依赖注入是实现IoC的两个方式之一（另一个是依赖查找），Spring通过依赖注入管理Bean之间的依赖关系 这里的依赖关系并不是指在编译时的继承、实现等关系，而是在实例化一个对象A前，必须要先实例化另一个对象B，相当于建立了一个运行时依赖关系 依赖注入的类型分为：引用类型（如类对象）、基本数据类型和String 注入方式常用的依赖注入方式有三种，在注入对象是不可变对象是选择构造方法注入，在注入对象是可变对象时能够选择setter注入 属性注入 优点：操作简单 缺点：1）不能注入不可变对象；2）通用性不好，只适用于IoC容器；3）可能导致依赖循环 setter注入 优点：1）通用性好；2）符合单一职责的设计原则；3）允许在类构造后进行重新注入 缺点：1）不能注入不可变对象；2）注入对象能够被修改 构造方法注入（推荐） 缺点：1）通用性好；2）能够注入不可变对象；3）注入对象不能被修改 注解注入 引用类型：在变量上添加注解@Autowired即可 基本数据类型+String：添加注解@Autowired，并使用注解@Value赋值 123@Autowired@Value(&quot;Hello&quot;)private String str; setter注入 在需要依赖注入的类中添加为变量添加set方法 123456private UserDao userDao;@Autowiredprivate void setUserDao(UserDao userDao){ this.userDao = userDao;} 构造方法注入 在需要依赖注入的类中使用构造方法注入变量 12345678private UserDao userDao;@Autowiredpublic UserServiceimpl(UserDao userDao) { this.userDao = userDao;}public UserServiceimpl() {} 当只有一个构造方法时，@Autowired可以省略 12345private UserDao userDao;public UserServiceimpl(UserDao userDao) { this.userDao = userDao;} AOPAOP：面向切面编程，是一种编程思想，旨在不改变原始设计的基础上为其增加功能 基本概念 连接点JoinPoint：Spring允许引用通知的地方，一般指方法 切入点Pointcut：增强的连接点 通知Advice：切入点具体增强的操作，可以是增加操作，也可以是抽取的通用操作 切面Aspect：通知+切入点 通知类型有五种通知类型：前置通知@Before、后置通知@After、返回后通知@AfterRunning、异常通知@AfterThrowing、环绕通知@Around （常用） 环绕通知规范： 必须使用proceedingJoinPoint对象执行原始方法，否则会隔离原始方法 无论原始方法返回值是什么，通知返回值都设为Object 通知获取数据获取的数据一般是参数、返回值、异常，不同通知方式获取数据的方式可能不同 获取切入点参数： 环绕通知：ProceedJoinPoint对象使用getArgs方法 其他通知：JoinPoint对象使用getArgs方法 获取返回值参数： 环绕通知：ProceedJoinPoint对象执行原始方法获取返回值 返回后通知 获取切入点方法异常信息 环绕通知 异常通知 环绕通知获取切入点参数并修改 12345678910111213141516@Component@Aspectpublic class UserAdvice { @Pointcut(&quot;execution(* org.example.Service.*.UserServiceimpl.testFunc(*))&quot;) private void gt() {} @Around(&quot;gt()&quot;) public Object testAop(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { Object[] args = proceedingJoinPoint.getArgs(); args[0] = 2; Object proceed = proceedingJoinPoint.proceed(args); return proceed; }}// Userbean.testFunc(1); 切入点表达式切入点表达式：用于描述要增强的方法 切入点表达式标准格式：动作关键字（访问修饰符 返回值 包名.类/接口名.方法名(参数) 异常名） 动作关键字：描述切入点的行为动作，一般为execution 访问修饰符：public、private，一般为public且可以省略 异常名：一般不写 为了简便书写切入点表达式，使用通配符进行描述 *：表示单个任意字段，也能表示前后缀 …：表示任意个任意字段，也能表示前后缀 +：专用于匹配子类类型 12// 描述com包下所有业务层接口中的find前缀且一个任意类型参数的所有方法execution (public * com..*Service.find*(*)) 切入点表达式规范： 降耦：尽量描述接口而非实现类 效率： 非必须情况下不使用..尽量使用多个*代替..提升效率 确定的字段使用精准匹配而非通配符 快速开始 导入坐标 开启Spring AOP 定义连接点，在通知类中定义通知和切入点 坐标 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.19&lt;/version&gt;&lt;/dependency&gt; 在配置类中开启AOP @EnableAspectJAutoProxy 通知类 1234567891011@Component@Aspectpublic class UserAdvice { @Pointcut(&quot;execution(* org.example.Service.*.UserServiceimpl.testFunc())&quot;) private void gt() {} @Before(&quot;gt()&quot;) public void testAop() { System.out.println(&quot;test AOP&quot;); }} 使用环绕通知 1234567891011121314@Component@Aspectpublic class UserAdvice { @Pointcut(&quot;execution(* org.example.Service.*.UserServiceimpl.testFunc())&quot;) private void gt() {} @Around(&quot;gt()&quot;) public Object testAop(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { System.out.println(&quot;执行方法前&quot;); Object proceed = proceedingJoinPoint.proceed(); System.out.println(&quot;执行方法后&quot;); return proceed; }}","link":"/2023/01/19/Spring/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/01/14/hello-world/"},{"title":"记第一次实习","text":"实习保研前看过许多保研经验帖，从中学到了很多，所以我也打算写一篇分享分享，后来由于各种原因放弃，现在随便记录下自己找实习的过程吧。 bg：有学校Java课程基础，有效自学时间大概一个月，水平较低 技术栈：JavaSE、SSM、SpringBoot、Mysql、Redis 思路：官网、招聘软件齐下，先小厂练手后中厂大厂 按时间顺序如下： 夜幻（拒offer） 面试简单，像是走流程，没锻炼到啥 图灵深视（去向） 问题全面，算法、计网、数据库、项目、场景问题都有 亚信科技（放弃面试） 太懒不想面 中科院软件所（放弃面试） 同上 绿盟（没过） 问题很深，侧重于实战，面试官很好，基本问的都是我的知识漏洞（ Mobvista（没过） 也是侧重于实战 欢欣科技（放弃面试） 即将旅游遂放弃 米哈游（放弃面试） 以应届生身份投的春招，目的是练练，放弃理由同上 小红书（放弃面试） 同7 字节（放弃面试） 太多事情不得不放弃 暂时就记得这些，以后再补~ Tips： 以前我一直觉得找实习很难，现在才明白，其实并没有，至少不去大厂并没有，另外学历意外好用，以我个人在某招聘软件上的经历为例： 左：教育经历只写本科；右：教育经历写上推免的学校","link":"/2023/03/23/%E6%89%BE%E5%AE%9E%E4%B9%A0/"},{"title":"苏州记","text":"","link":"/2023/03/23/%E8%8B%8F%E5%B7%9E%E8%A1%8C/"}],"tags":[],"categories":[{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"实习","slug":"实习","link":"/categories/%E5%AE%9E%E4%B9%A0/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"}]}